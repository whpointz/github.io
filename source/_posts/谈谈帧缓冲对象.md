---
title: 谈谈帧缓冲对象
date: 2017-09-17 14:56:24
tags: [图形]
---

[TOC]


# 概述
OpenGL渲染管线的最终位置是在**帧缓冲区**中，帧缓冲区是一系列二维的像素存储数组，包括了颜色缓冲区、深度缓冲区、模板缓冲区以及累积缓冲区。
默认情况下OpenGL使用的是**窗口系统**提供的帧缓冲区。

帧缓冲对象(FBO)提供了一系列的缓冲区，包括颜色缓冲区、深度缓冲区和模板缓冲区，这些逻辑的缓冲区可以绑定到FBO的二维像素数组中。

FBO中有两类绑定的对象：`纹理对象(Texture images)`和`渲染对象(Renderbuffer images)`。
- 纹理对象，那么OpenGL执行的是`渲染到纹理(Render to texture)`。
- 渲染对象，那么OpenGL执行的是`离屏渲染(offscreen rendering)`。

# FBO的概念
FBO可以理解成一个有很多挂载点的对象，**自身并不储存图像相关的数据**，但是提供了一种可以快速切换外部纹理对象和渲染对象挂载点的方式。
在FBO中必然包含了一个深度缓冲区挂载点和一个模板缓冲区挂载点，同时还有很多许多颜色缓冲区挂载点。
FBO挂载点用来挂载纹理对象和渲染对象，这两类对象中储存了真正的渲染数据。FBO提供了快速而有效的方法挂载对象：
- 纹理对象： `glFramebufferTexture2D`
- 渲染对象： `glFramebufferRenderbuffer`

# FBO的使用
## 创建FBO
``` c++
void glGenFramebuffers(GLsizei n, GLuint *ids);
```
- n:创建的帧缓冲区对象的数量
- ids：保存创建帧缓冲区对象ID的数组或者变量
- 当ids为0的时候，表示为**窗口系统**提供的帧缓冲区

FBO不使用之后，使用函数`glDeleteFramebuffers`删除该FBO。

## 绑定对象到FBO中
``` c++
void glBindFramebuffer(GLenum target, GLuint id);
```
- target:绑定的目标，该参数必须设置为 GL_FRAMEBUFFER
- id：由glGenFramebuffers创建的id
之后可以选择挂载`纹理对象`或者是`渲染对象`到FBO中。


# 纹理对象
## 创建纹理对象
Eg:创建一个256*256的纹理对象

``` c++
GLuint texture;
glGenTextures(1, &texture);
glBindTexture(GL_TEXTURE_2D, texture);
//纹理格式指定为GL_DEPTH_COMPONENT
glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, 256, 256, 0, GL_DEPTH_COMPONENT, GL_FLOAT, NULL);
glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
```

## 挂载纹理对象到FBO
``` c++
void glFramebufferTexture2D(GLenum target,
                       GLenum attachmentPoint,
                       GLenum textureTarget,
                       GLuint textureId,
                       GLint  level);

glFramebufferTexture2D (GL_FRAMEBUFFER,
                        GL_DEPTH_ATTACHMENT,
                        GL_TEXTURE_2D,
                        texture,
                        0);
```
- target:挂接的目标，必须指定为 GL_FRAMEBUFFER
- attachmentPoint:挂接点位，取值：GL_COLOR_ATTACHMENT0到GL_COLOR_ATTACHMENTn，GL_DEPTH_ATTACHMENT，GL_STENCIL_ATTACHMENT对应着上图中颜色缓冲区点位和深度以及模板缓冲区点位
- textureTarget：设置为二维纹理（GL_TEXTURE_2D）
- textureId：纹理对象的ID值（如果设置为0，那么纹理对象从FBO点位上解绑）
- level：mipmap的层级


# 渲染对象
## 创建渲染对象
渲染对象是用来绑定的缓冲区对象FBO上做**离屏渲染**的。它可以让场景直接渲染到这个对象中（而不是到窗口系统中显示），创建它的方法与创建FBO有点类似：
``` c++
void glGenRenderbuffers(GLsizei n, GLuint* ids) //创建
void glDeleteRenderbuffers(GLsizei n, const Gluint* ids) //删除
void glBindRenderbuffer(GLenum target, GLuint id) //绑定
```
---

绑定完成之后，需要为渲染对象开辟一块空间，使用下面函数完成：
``` c++
void glRenderbufferStorage(GLenum target,
    GLenum internalformat,
    GLsizei width,
    GLsizei height);
```
- target：指定目标，必须设置为GL_RENDERBUFFER
- internalformat：设置图像格式
- width和height：设置渲染对象的长和宽

---

Eg:创建一个256*256的RGBA颜色渲染缓存
``` c++
Gluint color;
glGenRenderbuffers(1, &color);
glBindRenderbuffer(GL_RENDERBUFFER,color);
glRenderbufferStorage(GL_RENDERBUFFER,GL_RGBA,256,256);
```

## 挂载渲染对象到FBO
``` c++
void glFramebufferRenderbuffer(GLenum target,
                               GLenum attachmentPoint,
                               GLenum renderbufferTarget,
                               GLuint renderbufferId);

glFramebufferRenderbuffer(  GL_FRAMEBUFFER,
                            GL_COLOR_ATTACHMENT0,
                            GL_RENDERBUFFER,
                            color)
```
第三个参数必须为：`GL_RENDERBUFFER`

# 检查FBO状态
当挂接完成之后，我们在执行FBO下面的操作之前，必须检查一下FBO的状态，使用以下的函数：
``` c++
GLenum Status = glCheckFramebufferStatus(GL_FRAMEBUFFER);

	if (Status != GL_FRAMEBUFFER_COMPLETE) {
		printf("FB error, status: 0x%x\n", Status);
		return false;
	}
```

# 渲染到纹理对象 或者 离线渲染
``` c++
//渲染到纹理 或者 离线渲染
//主要看FBO中绑定的是什么
void MyFBO::BindForWriting()
{
	glBindFramebuffer(GL_DRAW_FRAMEBUFFER, m_fbo);
}

```
